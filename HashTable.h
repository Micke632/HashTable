#pragma once


#include <vector>
#include <functional>

namespace stml {

	template <typename K, typename V,
		typename Alloc = std::allocator<V>>
		class HashTable
	{
	public:
		using size_type = unsigned int;
		using hash_type = std::size_t;
	private:
		template <typename K, typename V >
		struct Node
		{			
			K key = {};
			V value = {};
			hash_type hash = {};
			Node *next = {};
		};

		using node_type = Node<K, V>;
		using node_allocator = typename Alloc::template rebind<node_type>::other;
		node_allocator m_allocator;
		using reference = V & ;
		using const_reference = const V&;

		std::vector<node_type*, Alloc> m_pool;

		const int MAX_ITEMS_IN_BUCKET = 10;			
		const double LOAD_FACTOR = 0.90;				

		//const std::vector<size_type> m_bucketSizes = { 4, 16, 64, 128, 512, 1024, 4096, 8192, 16384, 32768, 65536, 131072,  524288, 1048576, 2097152 };
		const std::vector<unsigned int> m_bucketSizes = { 3, 13, 97, 311, 719, 1931,7793, 19391, 37199, 99371, 193939, 500299,  1300463, 2613229,4148279 };
		unsigned int m_currentBucketSizeIndex = 1;		//default 16
		std::hash<std::string> m_stringHasher;

		static int setLast(node_type *node_next , node_type *node) {					

			int i = 1;
			auto *n = node_next;
			while (n != nullptr) {
				node_next = n;
				n = n->next;
				i++;
			}
			node_next->next = node;
			return i;
		}

		struct prime_number_hash_policy
		{
			static size_t mod0(size_t) { return 0llu; }
			static size_t mod2(size_t hash) { return hash % 2llu; }
			static size_t mod3(size_t hash) { return hash % 3llu; }
			static size_t mod5(size_t hash) { return hash % 5llu; }
			static size_t mod7(size_t hash) { return hash % 7llu; }
			static size_t mod11(size_t hash) { return hash % 11llu; }
			static size_t mod13(size_t hash) { return hash % 13llu; }
			static size_t mod17(size_t hash) { return hash % 17llu; }
			static size_t mod23(size_t hash) { return hash % 23llu; }
			static size_t mod29(size_t hash) { return hash % 29llu; }
			static size_t mod37(size_t hash) { return hash % 37llu; }
			static size_t mod47(size_t hash) { return hash % 47llu; }

			using mod_function = size_t(*)(size_t);

			mod_function next_size_over(size_t & size) const
			{
				// prime numbers generated by the following method:
				// 1. start with a prime p = 2
				// 2. go to wolfram alpha and get p = NextPrime(2 * p)
				// 3. repeat 2. until you overflow 64 bits
				// you now have large gaps which you would hit if somebody called reserve() with an unlucky number.
				// 4. to fill the gaps for every prime p go to wolfram alpha and get ClosestPrime(p * 2^(1/3)) and ClosestPrime(p * 2^(2/3)) and put those in the gaps
				// 5. get PrevPrime(2^64) and put it at the end
				static constexpr const size_t prime_list[] =
				{
					2llu, 3llu, 5llu, 7llu, 11llu, 13llu, 17llu, 23llu, 29llu, 37llu, 47llu,
					59llu, 73llu, 97llu, 127llu, 151llu, 197llu, 251llu, 313llu, 397llu,
					499llu, 631llu, 797llu, 1009llu, 1259llu, 1597llu, 2011llu, 2539llu
				};

				static constexpr size_t(*const mod_functions[])(size_t) =
				{
					&mod0, &mod2, &mod3, &mod5, &mod7, &mod11, &mod13, &mod17, &mod23, &mod29, &mod37,
					&mod47, &mod59, &mod73, &mod97, &mod127, &mod151, &mod197, &mod251, &mod313, &mod397,
					&mod499, &mod631, &mod797, &mod1009, &mod1259, &mod1597, &mod2011, &mod2539, &mod3203,
					&mod4027, &mod5087, &mod6421, &mod8089, &mod10193, &mod12853, &mod16193, &mod20399
				};
				const size_t * found = std::lower_bound(std::begin(prime_list), std::end(prime_list) - 1, size);
				size = *found;
				return mod_functions[1 + found - prime_list];
			}
				void commit(mod_function new_mod_function)
				{
					current_mod_function = new_mod_function;
				}
				void reset()
				{
					current_mod_function = &mod0;
				}

				size_t index_for_hash(size_t hash, size_t /*num_slots_minus_one*/) const
				{
					return current_mod_function(hash);
				}
				size_t keep_in_range(size_t index, size_t num_slots_minus_one) const
				{
					return index > num_slots_minus_one ? current_mod_function(index) : index;
				}

			private:
				mod_function current_mod_function = &mod0;
		};
	
		size_type calcPos(hash_type hash) const {
			return hash % m_bucketSize ;		
		}

		prime_number_hash_policy hash_policy;

		template <typename K, typename V >
		struct Bucket {

			Bucket() {			
				active = false;
			}

			void removeNodes(node_allocator &allocator) {
				auto *next = node.next;
				auto *n = next;
				while (next != nullptr) {
					next = next->next;
					allocator.destroy(n);
					allocator.deallocate(n, 1);
					n = next;
				}
				node.next = nullptr;
				active = false;
			
			}


			Bucket *copy(HashTable *home) const {
				Bucket *bucket = new Bucket<K, V>();

				auto *this_bucket_next = this->node.next;

				bucket->active = this->active;
				if (bucket->active) {
					bucket->node.key = this->node.key;
					bucket->node.value = this->node.value;
					bucket->node.hash  = this->node.hash;
				}

				

				while (this_bucket_next != nullptr) {

					auto *node = home->getNode();
					node->key = this_bucket_next->key;
					node->value = this_bucket_next->value;
					node->hash = this_bucket_next->hash;
					node->next = nullptr;
				

					this_bucket_next = this_bucket_next->next;

					if (bucket->node.next == nullptr) {
						bucket->node.next = node;
					}
					else {
						//find end
						setLast(bucket->node.next, node);
					}

				}
		
				return bucket;
			}
					
			bool active;		   // flag if the first node is used ( it is not in the linked list)
			Node<K, V> node;

		};

		using bucket_vector = std::vector<Bucket<K, V>*, Alloc>;



	public:



		class iterator_base {

		public:

			using iterator_category = std::forward_iterator_tag;
			using value_type = void;
			using difference_type = size_type;
			using pointer = void;
			using reference = void;
		protected:
			friend class HashTable;

			node_type* findNext() const {

				if (m_lastBucket >= m_buckets->size()) {
					return nullptr;
				}

				auto *bucket = (*m_buckets)[m_lastBucket];
				if (!m_checkedFirst) {
					if (bucket->active) {
						m_checkedFirst = true;
						return &bucket->node;
					}

					m_checkedFirst = true;
					m_node = nullptr;
				}

				auto *node = bucket->node.next;
				if (node == nullptr) {
					m_checkedFirst = false;
					m_lastBucket++;
					return findNext();
				}

				if (m_checkedFirst) {
					if (m_node == &bucket->node) 
					{
						m_node = nullptr;
					}
				}

				while (node != nullptr) {

					if (m_node && m_node == node) {
						m_node = m_node->next;
						break;
					}
					if (!m_node) {
						m_node = node;
						break;
					}

					node = node->next;
				}


				if (!m_node) {
					m_lastBucket++;
					m_checkedFirst = false;
					return findNext();
				}
				return m_node;

			}

			//end iterator
			iterator_base() :
				m_buckets(nullptr),
				m_lastBucket(0),
				m_node(nullptr),
				m_size(0),
				m_count(0)
			{
			}

			iterator_base(node_type *n,
				const bucket_vector *ptr,
				size_type pos,
				size_type tot,
				bool checkedFirst) :
				m_buckets(ptr),
				m_lastBucket(pos),
				m_node(n),
				m_size(tot),
				m_count(0),
				m_checkedFirst(checkedFirst)
			{
				if (m_node == nullptr)
					m_node = findNext();
			}


		public:
					

			bool operator != (const iterator_base &other) const {
				return m_node != other.m_node;
			}
			bool operator == (const iterator_base &other) const {
				return m_node == other.m_node;
			}
	
						
		protected:
			const bucket_vector *m_buckets;
			mutable size_type m_lastBucket;
			size_type m_size;
			size_type m_count;
			mutable node_type *m_node;
			mutable bool m_checkedFirst;	//first item in every bucket works different than the rest so a boolean is needed

		};

		class iterator : public iterator_base {
			
			friend class HashTable;

			iterator(){}
			iterator(node_type *n,
				const bucket_vector *ptr,
				size_type pos,
				size_type tot,
				bool checkedFirst):iterator_base(n,ptr,pos,tot,checkedFirst){

			}

		public:
			std::pair<const K&, V&> operator*() const { return { m_node->key,m_node->value }; }

			//pre
			iterator & operator++() {
				if (++m_count >= m_size)
					m_node = nullptr;
				else
					m_node = findNext();

				return *this;
			}

			//post
			iterator operator++(int) {

				iterator it(m_node, m_buckets, m_lastBucket, m_size, m_checkedFirst);
				if (++m_count >= m_size)
					m_node = nullptr;
				else
					m_node = findNext();

				return it;
			}

		};
	
		iterator createIterator(node_type *node, size_type pos, bool skipFirst = true) const {
			return iterator(node, &m_buckets, pos, m_size, skipFirst);
		}

		iterator createEndIterator() const {
			return iterator();
		}


		node_type* getNode() {
			if (!m_pool.empty()) {
				auto *p = m_pool.back();
				m_pool.pop_back();
				return p;

			}

			auto *node = m_allocator.allocate(1);
			//allocator.construct(node);
			return node;
		}
		
	
		void  releaseNode(node_type* node) {
			m_pool.push_back(node);
		}

	

		template <typename V>
		int insertEmplace(size_type pos, hash_type hash, const K& key, V &&value) {

			auto *bucket = m_buckets[pos];
			if (!bucket->active) {

				bucket->node.key = key;
				bucket->node.value = std::move(value);
				bucket->node.hash = hash;
				bucket->active = true;
				m_nonemptyCount++;
			}
			else {			
				auto *node = getNode();				
				node->key = key;
				node->value = std::move(value);
				node->hash = hash;
				node->next = nullptr;
				if (bucket->node.next == nullptr) {
					bucket->node.next = node;
					return 1;
				}
				return setLast(bucket->node.next, node);	
			}

			return 1;
		}

		void insert(std::pair<node_type*, size_type > &node) {

			assert(node.first->next == nullptr);
					

			auto *bucket = m_buckets[node.second];
			if (!bucket->active) {
				bucket->node.key = std::move(node.first->key);
				bucket->node.value = std::move(node.first->value);
				bucket->node.hash = node.first->hash;		
				bucket->active = true;
				releaseNode(node.first);			
			}
			else {
				if (bucket->node.next == nullptr) {
					bucket->node.next = node.first;
					return;
				}
				//find end
				setLast(bucket->node.next, node.first);
			

			}
		}


		template< typename K >
		typename std::enable_if< !std::is_integral< K >::value &&  !std::is_pointer< K >::value, hash_type>::type
			getHash(const K &key) const {
			hash_type h = key.getHash();
			return h;
		}

		template< typename K >
		typename std::enable_if< !std::is_integral< K >::value && std::is_pointer< K >::value, hash_type>::type
			getHash(const K &key) const {
			hash_type h = key->getHash();
			return h;
		}

		
		template< typename K >
		typename std::enable_if< std::is_integral< K >::value, hash_type >::type
			getHash(const K &key) const {
			return key;
		}
		//string overloading
		hash_type getHash(const std::string &key) const {
			return m_stringHasher(key);
		}


	

		void moveToFront(Bucket<K, V> *bucket) {

			if (!bucket->active && bucket->node.next) {
				auto *node = bucket->node.next;
				bucket->node.key = std::move(node->key);
				bucket->node.value = std::move(node->value);
				bucket->node.hash = node->hash;
				bucket->active = true;
				if (node->next) {
					bucket->node.next = node->next;
				}
				else {
					bucket->node.next = nullptr;
				}
				releaseNode(node);
			}
		}



		void rehash() {
			m_nonemptyCount = 0;
		
			size_type newsize = 0;;

		//	hash_policy.next_size_over(num_buckets);
			
			if (m_currentBucketSizeIndex == m_bucketSizes.size() -1) {
				newsize = m_bucketSize * 2;			//TODO : add more to m_bucketSizes
			}
			else {
				newsize = m_bucketSizes[++m_currentBucketSizeIndex];
			}
			

			m_buckets.resize(newsize);

			for (size_type i = m_bucketSize; i < newsize; i++) {
				m_buckets[i] = new Bucket<K, V>();
			}
			size_type old = m_bucketSize;
			m_bucketSize = newsize;

			std::vector< std::pair<node_type*, size_type> > moveNodes;
			moveNodes.reserve(old);

			size_type empty = 0;

			for (size_type i = 0; i < old; i++) {
				auto *bucket = m_buckets[i];
			
				if (bucket->active) {			
					size_type newPos = calcPos(bucket->node.hash);
					if (newPos != i) {
						auto *node = getNode();
						node->key = std::move(bucket->node.key);
						node->value = std::move(bucket->node.value);
						node->hash = bucket->node.hash;
						node->next = nullptr;
						bucket->active = false;
					
						moveNodes.emplace_back(node, newPos);
					}
				}

				auto *HOME = bucket->node.next;  	//points to bucket->node.next
				auto *node = bucket->node.next;
				auto *prev = bucket->node.next;		//points to previos active node
				if (!node && !bucket->active) {
					empty++;
				}
				while (node) {
								
					size_type newPos = calcPos(node->hash);
					auto *next_node = node->next;
					if (newPos != i) {
						//remove the node from this bucket
						if (node == HOME) {
							bucket->node.next = next_node;
							HOME = bucket->node.next;
						}
						else {
							prev->next = next_node;
						}
					
						node->next = nullptr;
						moveNodes.emplace_back(node, newPos);

					}
					else {
						prev = node;
					}

					node = next_node;

				}

				moveToFront(bucket);

			}
		

			for (auto &n : moveNodes) {
				insert(n);
			}

			calcEmpty();
			m_saveEmpty.push_back(empty / (double)old * 100 );

		}

		const_reference	at(K const &key) const {
			hash_type hash = getHash(key);
			size_type pos = calcPos(hash);

			auto *bucket = m_buckets[pos];
			if (bucket->active && bucket->node.hash == hash && bucket->node.key == key) {
				return bucket->node.value;
			}
			auto *node = bucket->node.next;

			while (node != nullptr) {
				if (node->hash == hash && node->key == key) {
					return node->value;
				}
				node = node->next;
			}

			throw std::runtime_error("not found");

		}

		iterator removeAtEx(hash_type hash, const K& key) {
			size_type pos = calcPos(hash);
			auto *bucket = m_buckets[pos];

			if (bucket->active && bucket->node.hash == hash && bucket->node.key == key) {
				bucket->active = false;
				m_size--;				
				moveToFront(bucket);	//check if we can move the next to the front
				
				if (!bucket->active)
					m_nonemptyCount--;

				return bucket->active ? createIterator(&bucket->node, pos) : createIterator(bucket->node.next, pos);

			}

			if (bucket->node.next) {
				auto *node = bucket->node.next;
				if (node->hash == hash  && node->key==key) {
					auto *next_n = node->next;
					releaseNode(node);			
					bucket->node.next = next_n;
					m_size--;

					return createIterator(next_n, pos);
				}
				auto *prev = node;
				node = bucket->node.next->next;
				while (node != nullptr) {

					if (node->hash == hash && node->key == key) {

						auto *next_n = node->next;
						prev->next = next_n;					
						m_size--;
						releaseNode(node);

						return createIterator(next_n, pos);
					}

					prev = node;
					node = node->next;
				}
			}

			return end();
		}


	public:


		node_allocator & get_allocator() {
			return m_allocator;
		}

		

		iterator begin() const {
			return createIterator(nullptr, 0, false);
		}
		iterator end() const {
			return m_end;
		}

		explicit HashTable(size_type bucketSize = 16) {
			if (bucketSize != 16) {
				if (bucketSize <= m_bucketSizes[0]) {
					bucketSize = m_bucketSizes[0];
					m_currentBucketSizeIndex = 0;
				}
				else {
					unsigned int i = 1;
					for (unsigned int p : m_bucketSizes) {
						if (bucketSize <= m_bucketSizes[i]) {
							bucketSize = m_bucketSizes[i];
							m_currentBucketSizeIndex = i;
							break;
						}
						i++;
					}
				}

			}
			m_nonemptyCount = 0;
			m_bucketFull = false;
			m_pool.reserve(20);
			m_bucketSize = bucketSize;
			m_size = 0;
			m_buckets.reserve(m_bucketSize);
			for (size_type i = 0; i < m_bucketSize; i++) {
				m_buckets.push_back(new Bucket<K, V>());
			}
		}

		~HashTable()
		{
			destroy();
		};

		bool check() const {		
			//not used
			return true;
		}

		float emptyCount() const {		
			return 1.0f*(m_bucketSize - m_nonemptyCount) /m_bucketSize;
			
		}

		void calcEmpty() {
			size_type empty = 0;
			for (size_type i = 0; i < m_bucketSize; i++) {
				if (!m_buckets[i]->active || !m_buckets[i]->node.next) {
					empty++;
				}
			}
			m_nonemptyCount = m_bucketSize - empty;
		}

		void destroy() {
			for (size_type i = 0; i < m_bucketSize; i++) {
				m_buckets[i]->removeNodes(m_allocator);
				delete m_buckets[i];
			}
			m_buckets.clear();
			m_bucketSize = 0;
			m_size = 0;
			m_nonemptyCount = 0;
			while (!m_pool.empty()) {
				m_allocator.destroy(m_pool.back());
				m_allocator.deallocate(m_pool.back(), 1);
				m_pool.pop_back();
			}

		}

		HashTable(HashTable &&other)
		{
			m_pool = std::move(other.m_pool);
			m_bucketSize = std::move(other.m_bucketSize);
			m_size = std::move(other.m_size);
			m_buckets = std::move(other.m_buckets);
			m_currentBucketSizeIndex = std::move(other.m_currentBucketSizeIndex);
			m_saveEmpty = std::move(other.m_saveEmpty);
			m_nonemptyCount = std::move(other.m_nonemptyCount);
			other.m_bucketSize = 0;
			other.m_size = 0;
		}

		HashTable& operator=(HashTable &&other) {

			destroy();

			m_pool = std::move(other.m_pool);
			m_bucketSize = std::move(other.m_bucketSize);
			m_size = std::move(other.m_size);
			m_buckets = std::move(other.m_buckets);
			m_currentBucketSizeIndex = std::move(other.m_currentBucketSizeIndex);
			m_saveEmpty = std::move(other.m_saveEmpty);
			m_nonemptyCount = std::move(other.m_nonemptyCount);
			other.m_bucketSize = 0;
			other.m_size = 0;

			return *this;
		}

		HashTable& operator=(const HashTable &other)
		{
			destroy();

			m_bucketSize = other.m_bucketSize;
			m_size = other.m_size;
			m_buckets.reserve(m_bucketSize);
			m_currentBucketSizeIndex = other.m_currentBucketSizeIndex;
			m_nonemptyCount = other.m_nonemptyCount;

			for (size_type i = 0; i < m_bucketSize; i++) {
				auto *b = other.m_buckets[i]->copy(this);
				m_buckets.push_back(b);
			}
			return *this;
		}

		HashTable(const HashTable &other)
		{
			m_bucketSize = other.m_bucketSize;
			m_size = other.m_size;
			m_buckets.reserve(m_bucketSize);
			m_currentBucketSizeIndex = other.m_currentBucketSizeIndex;
			m_nonemptyCount = other.m_nonemptyCount;
			for (size_type i = 0; i < m_bucketSize; i++) {
				auto *b = other.m_buckets[i]->copy(this);
				m_buckets.push_back(b);
			}

		}

		reference operator[](const K &key) {

			if (exist(key)) {
				return get(key);
			}
			else {
				V v{};
				add(key, v);
				return get(key);
			}
		}

		const_reference operator[](const K &key) const {
			return get(key);
		}

		template <typename V>
		void emplace(const K& key, V&& value) {

			hash_type hash = getHash(key);
		
			size_type pos = calcPos(hash);

			auto *bucket = m_buckets[pos];

			if (bucket->active && bucket->node.hash == hash && bucket->node.key == key) {
				bucket->node.value = std::move(value);
				return;
			}
			auto *node = bucket->node.next;

			while (node != nullptr) {
				if (node->hash == hash && node->key == key) {
					node->value = std::move(value);
					return;
				}
				node = node->next;
			}

			int count = insertEmplace(pos, hash, key, std::move(value));

			m_size++;

			if (m_size > 20) {
				float f = (1.0f*m_size) / m_bucketSize;
				if (f > LOAD_FACTOR) {
					
					float bucketsEmpty = emptyCount();
					if ( count >= MAX_ITEMS_IN_BUCKET  || bucketsEmpty < 0.1) {
						rehash();
					}
				}
			}
		}

		void add(const K& key, const V &value) {
			emplace(key, value);
		}
		
		void add(const K& key, V &&value) {
			emplace(key, std::move(value));		
		}



		size_type size() const {
			return m_size;
		}

		size_type getBucketSize() const {
			return m_bucketSize;
		}



		iterator find(K const &key) const {
			hash_type hash = getHash(key);
			size_type pos = calcPos(hash);

			auto *bucket = m_buckets[pos];
			if (bucket->active && bucket->node.hash == hash && bucket->node.key == key) {
				return createIterator(&bucket->node, pos);
			}
			auto *node = bucket->node.next;
			while (node != nullptr) {
				if (node->hash == hash && node->key == key) {
					return createIterator(node, pos);
				}

				node = node->next;
			}

			return end();
		}

		reference get(K const &key) {
			return const_cast<V&>(const_cast<const HashTable*>(this)->at(key));
		}

		const_reference get(K const &key) const {
			return at(key);
		}


		bool remove(K const &key) {
			size_type temp = m_size;
			hash_type hash = getHash(key);
			removeAtEx(hash, key);
			return temp > m_size;
		}



		iterator remove(const iterator &it) {
			if (it == end()) return end();
			hash_type hash = getHash(it.m_node->key);
			return removeAtEx(hash, it.m_node->key);
		}


		bool exist(K const &key) const {
			hash_type hash = getHash(key);
			size_type pos = calcPos(hash);
			auto *bucket = m_buckets[pos];	
			if (bucket->active && bucket->node.hash == hash && bucket->node.key == key) {
				return true;
			}
			auto *node = bucket->node.next;
			while (node != nullptr) {
				if (node->hash == hash && node->key == key) {
					return true;
				}
				node = node->next;
			}

			return false;
		}

		//clears and trims down the internal structure 
		void clearAndTrim() {

			clear();
			
		
			m_currentBucketSizeIndex = m_currentBucketSizeIndex / 2;
						
			size_type bucketSize = m_bucketSizes[m_currentBucketSizeIndex];

			for (size_type i = bucketSize; i < m_bucketSize; i++) {
				delete m_buckets[i];
			}

			m_buckets.resize(bucketSize);
			m_bucketSize = bucketSize;

			m_buckets.shrink_to_fit();
		}

		void clear() {

			for (size_type i = 0; i < m_bucketSize; i++) {
				auto *bucket = m_buckets[i];
				bucket->removeNodes(m_allocator);
			}
			m_size = 0;

			while (!m_pool.empty()) {
				m_allocator.destroy(m_pool.back());
				m_allocator.deallocate(m_pool.back(), 1);
				m_pool.pop_back();
			}

		}

		std::vector<int> getRehashInfo() const{
			return m_saveEmpty;
		}


	private:

		bucket_vector m_buckets;
		iterator	m_end;		//end() iterator 
		size_type m_size;
		size_type m_bucketSize;
		bool	  m_bucketFull;
		std::vector<int> m_saveEmpty;
		size_t m_nonemptyCount;
	};


}

